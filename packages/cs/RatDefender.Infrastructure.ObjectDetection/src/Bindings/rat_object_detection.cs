// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.8.4+v0.25.0
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;

namespace uniffi.rat_object_detection;

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer
{
    public int capacity;
    public int len;
    public IntPtr data;

    public static RustBuffer Alloc(int size)
    {
        return _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                var buffer =
                    _UniFFILib.ffi_rat_object_detection_rustbuffer_alloc(
                        size,
                        ref status
                    );
                if (buffer.data == IntPtr.Zero)
                {
                    throw new AllocationException(
                        $"RustBuffer.Alloc() returned null data pointer (size={size})"
                    );
                }
                return buffer;
            }
        );
    }

    public static void Free(RustBuffer buffer)
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                _UniFFILib.ffi_rat_object_detection_rustbuffer_free(
                    buffer,
                    ref status
                );
            }
        );
    }

    public static BigEndianStream MemoryStream(IntPtr data, int length)
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), length)
            );
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), len)
            );
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    capacity,
                    capacity,
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes
{
    public int length;
    public IntPtr data;
}

// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType>
{
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value)
    {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try
        {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToInt32(stream.Position);
            return rbuf;
        }
        catch
        {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf)
    {
        var stream = rbuf.AsStream();
        try
        {
            var item = Read(stream);
            if (stream.HasRemaining())
            {
                throw new InternalException(
                    "junk remaining in buffer after lifting, something is very wrong!!"
                );
            }
            return item;
        }
        finally
        {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType>
    : FfiConverter<CsType, RustBuffer>
{
    public override CsType Lift(RustBuffer value)
    {
        return LiftFromRustBuffer(value);
    }

    public override RustBuffer Lower(CsType value)
    {
        return LowerIntoRustBuffer(value);
    }
}

// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct RustCallStatus
{
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess()
    {
        return code == 0;
    }

    public bool IsError()
    {
        return code == 1;
    }

    public bool IsPanic()
    {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
internal class UniffiException : System.Exception
{
    public UniffiException()
        : base() { }

    public UniffiException(string message)
        : base(message) { }
}

internal class UndeclaredErrorException : UniffiException
{
    public UndeclaredErrorException(string message)
        : base(message) { }
}

internal class PanicException : UniffiException
{
    public PanicException(string message)
        : base(message) { }
}

internal class AllocationException : UniffiException
{
    public AllocationException(string message)
        : base(message) { }
}

internal class InternalException : UniffiException
{
    public InternalException(string message)
        : base(message) { }
}

internal class InvalidEnumException : InternalException
{
    public InvalidEnumException(string message)
        : base(message) { }
}

internal class UniffiContractVersionException : UniffiException
{
    public UniffiContractVersionException(string message)
        : base(message) { }
}

internal class UniffiContractChecksumException : UniffiException
{
    public UniffiContractChecksumException(string message)
        : base(message) { }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E>
    where E : System.Exception
{
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler : CallStatusErrorHandler<UniffiException>
{
    public static NullCallStatusErrorHandler INSTANCE =
        new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf)
    {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException(
            "library has returned an error not declared in UNIFFI interface file"
        );
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers
{
    public delegate void RustCallAction(ref RustCallStatus status);
    public delegate U RustCallFunc<out U>(ref RustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(
        CallStatusErrorHandler<E> errorHandler,
        RustCallFunc<U> callback
    )
        where E : UniffiException
    {
        var status = new RustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess())
        {
            return return_value;
        }
        else if (status.IsError())
        {
            throw errorHandler.Lift(status.error_buf);
        }
        else if (status.IsPanic())
        {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0)
            {
                throw new PanicException(
                    FfiConverterString.INSTANCE.Lift(status.error_buf)
                );
            }
            else
            {
                throw new PanicException("Rust panic");
            }
        }
        else
        {
            throw new InternalException(
                $"Unknown rust call status: {status.code}"
            );
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(
        CallStatusErrorHandler<E> errorHandler,
        RustCallAction callback
    )
        where E : UniffiException
    {
        _UniffiHelpers.RustCallWithError(
            errorHandler,
            (ref RustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback)
    {
        return _UniffiHelpers.RustCallWithError(
            NullCallStatusErrorHandler.INSTANCE,
            callback
        );
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback)
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }
}

static class FFIObjectUtil
{
    public static void DisposeAll(params Object?[] list)
    {
        foreach (var obj in list)
        {
            Dispose(obj);
        }
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
    private static void Dispose(dynamic? obj)
    {
        if (obj == null)
        {
            return;
        }

        if (obj is IDisposable disposable)
        {
            disposable.Dispose();
            return;
        }

        var type = obj.GetType();
        if (type != null)
        {
            if (type.IsGenericType)
            {
                if (
                    type.GetGenericTypeDefinition()
                        .IsAssignableFrom(typeof(List<>))
                )
                {
                    foreach (var value in obj)
                    {
                        Dispose(value);
                    }
                }
                else if (
                    type.GetGenericTypeDefinition()
                        .IsAssignableFrom(typeof(Dictionary<,>))
                )
                {
                    foreach (var value in obj.Values)
                    {
                        Dispose(value);
                    }
                }
            }
        }
    }
}

// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException : System.Exception
{
    public StreamUnderflowException() { }
}

class BigEndianStream
{
    Stream stream;

    public BigEndianStream(Stream stream)
    {
        this.stream = stream;
    }

    public bool HasRemaining()
    {
        return (stream.Length - stream.Position) > 0;
    }

    public long Position
    {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] value)
    {
        stream.Write(value, 0, value.Length);
    }

    public void WriteByte(byte value)
    {
        stream.WriteByte(value);
    }

    public void WriteUShort(ushort value)
    {
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteUInt(uint value)
    {
        stream.WriteByte((byte)(value >> 24));
        stream.WriteByte((byte)(value >> 16));
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteULong(ulong value)
    {
        WriteUInt((uint)(value >> 32));
        WriteUInt((uint)value);
    }

    public void WriteSByte(sbyte value)
    {
        stream.WriteByte((byte)value);
    }

    public void WriteShort(short value)
    {
        WriteUShort((ushort)value);
    }

    public void WriteInt(int value)
    {
        WriteUInt((uint)value);
    }

    public void WriteFloat(float value)
    {
        unsafe
        {
            WriteInt(*((int*)&value));
        }
    }

    public void WriteLong(long value)
    {
        WriteULong((ulong)value);
    }

    public void WriteDouble(double value)
    {
        WriteLong(BitConverter.DoubleToInt64Bits(value));
    }

    public byte[] ReadBytes(int length)
    {
        CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte()
    {
        CheckRemaining(1);
        return Convert.ToByte(stream.ReadByte());
    }

    public ushort ReadUShort()
    {
        CheckRemaining(2);
        return (ushort)(stream.ReadByte() << 8 | stream.ReadByte());
    }

    public uint ReadUInt()
    {
        CheckRemaining(4);
        return (uint)(
            stream.ReadByte() << 24
            | stream.ReadByte() << 16
            | stream.ReadByte() << 8
            | stream.ReadByte()
        );
    }

    public ulong ReadULong()
    {
        return (ulong)ReadUInt() << 32 | (ulong)ReadUInt();
    }

    public sbyte ReadSByte()
    {
        return (sbyte)ReadByte();
    }

    public short ReadShort()
    {
        return (short)ReadUShort();
    }

    public int ReadInt()
    {
        return (int)ReadUInt();
    }

    public float ReadFloat()
    {
        unsafe
        {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong()
    {
        return (long)ReadULong();
    }

    public double ReadDouble()
    {
        return BitConverter.Int64BitsToDouble(ReadLong());
    }

    private void CheckRemaining(int length)
    {
        if (stream.Length - stream.Position < length)
        {
            throw new StreamUnderflowException();
        }
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail which will be called internally by the public API.
static class _UniFFILib
{
    static _UniFFILib()
    {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
    }

    [DllImport("rat_object_detection")]
    public static extern void uniffi_rat_object_detection_fn_free_anyerror(
        IntPtr ptr,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void uniffi_rat_object_detection_fn_free_ratdetector(
        IntPtr ptr,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern RustBuffer uniffi_rat_object_detection_fn_method_ratdetector_run(
        IntPtr @ptr,
        RustBuffer @args,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void uniffi_rat_object_detection_fn_func_initialize(
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern IntPtr uniffi_rat_object_detection_fn_func_new_rat_detector_from_default_model_and_video_capture_file(
        RustBuffer @videoCaptureFile,
        RustBuffer @options,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern IntPtr uniffi_rat_object_detection_fn_func_new_rat_detector_from_default_model_and_video_capture_index(
        uint @videoCaptureIndex,
        RustBuffer @options,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern IntPtr uniffi_rat_object_detection_fn_func_new_rat_detector_from_files(
        RustBuffer @modelFile,
        RustBuffer @videoCaptureFile,
        RustBuffer @options,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern IntPtr uniffi_rat_object_detection_fn_func_new_rat_detector_from_model_bytes_and_video_capture_file(
        RustBuffer @modelBytes,
        RustBuffer @videoCaptureFile,
        RustBuffer @options,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern IntPtr uniffi_rat_object_detection_fn_func_new_rat_detector_from_model_bytes_and_video_capture_index(
        RustBuffer @modelBytes,
        uint @videoCaptureIndex,
        RustBuffer @options,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern IntPtr uniffi_rat_object_detection_fn_func_new_rat_detector_from_model_file_and_video_capture_index(
        RustBuffer @modelFile,
        uint @videoCaptureIndex,
        RustBuffer @options,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern RustBuffer ffi_rat_object_detection_rustbuffer_alloc(
        int @size,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern RustBuffer ffi_rat_object_detection_rustbuffer_from_bytes(
        ForeignBytes @bytes,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rustbuffer_free(
        RustBuffer @buf,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern RustBuffer ffi_rat_object_detection_rustbuffer_reserve(
        RustBuffer @buf,
        int @additional,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_continuation_callback_set(
        IntPtr @callback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_u8(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_u8(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_u8(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern byte ffi_rat_object_detection_rust_future_complete_u8(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_i8(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_i8(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_i8(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern sbyte ffi_rat_object_detection_rust_future_complete_i8(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_u16(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_u16(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_u16(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern ushort ffi_rat_object_detection_rust_future_complete_u16(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_i16(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_i16(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_i16(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern short ffi_rat_object_detection_rust_future_complete_i16(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_u32(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_u32(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_u32(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern uint ffi_rat_object_detection_rust_future_complete_u32(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_i32(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_i32(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_i32(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern int ffi_rat_object_detection_rust_future_complete_i32(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_u64(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_u64(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_u64(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern ulong ffi_rat_object_detection_rust_future_complete_u64(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_i64(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_i64(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_i64(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern long ffi_rat_object_detection_rust_future_complete_i64(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_f32(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_f32(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_f32(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern float ffi_rat_object_detection_rust_future_complete_f32(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_f64(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_f64(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_f64(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern double ffi_rat_object_detection_rust_future_complete_f64(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_pointer(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_pointer(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_pointer(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern IntPtr ffi_rat_object_detection_rust_future_complete_pointer(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_rust_buffer(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_rust_buffer(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_rust_buffer(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern RustBuffer ffi_rat_object_detection_rust_future_complete_rust_buffer(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_poll_void(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_cancel_void(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_free_void(
        IntPtr @handle
    );

    [DllImport("rat_object_detection")]
    public static extern void ffi_rat_object_detection_rust_future_complete_void(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("rat_object_detection")]
    public static extern ushort uniffi_rat_object_detection_checksum_func_initialize();

    [DllImport("rat_object_detection")]
    public static extern ushort uniffi_rat_object_detection_checksum_func_new_rat_detector_from_default_model_and_video_capture_file();

    [DllImport("rat_object_detection")]
    public static extern ushort uniffi_rat_object_detection_checksum_func_new_rat_detector_from_default_model_and_video_capture_index();

    [DllImport("rat_object_detection")]
    public static extern ushort uniffi_rat_object_detection_checksum_func_new_rat_detector_from_files();

    [DllImport("rat_object_detection")]
    public static extern ushort uniffi_rat_object_detection_checksum_func_new_rat_detector_from_model_bytes_and_video_capture_file();

    [DllImport("rat_object_detection")]
    public static extern ushort uniffi_rat_object_detection_checksum_func_new_rat_detector_from_model_bytes_and_video_capture_index();

    [DllImport("rat_object_detection")]
    public static extern ushort uniffi_rat_object_detection_checksum_func_new_rat_detector_from_model_file_and_video_capture_index();

    [DllImport("rat_object_detection")]
    public static extern ushort uniffi_rat_object_detection_checksum_method_ratdetector_run();

    [DllImport("rat_object_detection")]
    public static extern uint ffi_rat_object_detection_uniffi_contract_version();

    static void uniffiCheckContractApiVersion()
    {
        var scaffolding_contract_version =
            _UniFFILib.ffi_rat_object_detection_uniffi_contract_version();
        if (24 != scaffolding_contract_version)
        {
            throw new UniffiContractVersionException(
                $"uniffi.rat_object_detection: uniffi bindings expected version `24`, library returned `{scaffolding_contract_version}`"
            );
        }
    }

    static void uniffiCheckApiChecksums()
    {
        {
            var checksum =
                _UniFFILib.uniffi_rat_object_detection_checksum_func_initialize();
            if (checksum != 7032)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.rat_object_detection: uniffi bindings expected function `uniffi_rat_object_detection_checksum_func_initialize` checksum `7032`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_rat_object_detection_checksum_func_new_rat_detector_from_default_model_and_video_capture_file();
            if (checksum != 12110)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.rat_object_detection: uniffi bindings expected function `uniffi_rat_object_detection_checksum_func_new_rat_detector_from_default_model_and_video_capture_file` checksum `12110`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_rat_object_detection_checksum_func_new_rat_detector_from_default_model_and_video_capture_index();
            if (checksum != 45617)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.rat_object_detection: uniffi bindings expected function `uniffi_rat_object_detection_checksum_func_new_rat_detector_from_default_model_and_video_capture_index` checksum `45617`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_rat_object_detection_checksum_func_new_rat_detector_from_files();
            if (checksum != 1223)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.rat_object_detection: uniffi bindings expected function `uniffi_rat_object_detection_checksum_func_new_rat_detector_from_files` checksum `1223`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_rat_object_detection_checksum_func_new_rat_detector_from_model_bytes_and_video_capture_file();
            if (checksum != 30584)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.rat_object_detection: uniffi bindings expected function `uniffi_rat_object_detection_checksum_func_new_rat_detector_from_model_bytes_and_video_capture_file` checksum `30584`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_rat_object_detection_checksum_func_new_rat_detector_from_model_bytes_and_video_capture_index();
            if (checksum != 27557)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.rat_object_detection: uniffi bindings expected function `uniffi_rat_object_detection_checksum_func_new_rat_detector_from_model_bytes_and_video_capture_index` checksum `27557`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_rat_object_detection_checksum_func_new_rat_detector_from_model_file_and_video_capture_index();
            if (checksum != 34493)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.rat_object_detection: uniffi bindings expected function `uniffi_rat_object_detection_checksum_func_new_rat_detector_from_model_file_and_video_capture_index` checksum `34493`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_rat_object_detection_checksum_method_ratdetector_run();
            if (checksum != 30928)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.rat_object_detection: uniffi bindings expected function `uniffi_rat_object_detection_checksum_method_ratdetector_run` checksum `30928`, library returned `{checksum}`"
                );
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt8 : FfiConverter<byte, byte>
{
    public static FfiConverterUInt8 INSTANCE = new FfiConverterUInt8();

    public override byte Lift(byte value)
    {
        return value;
    }

    public override byte Read(BigEndianStream stream)
    {
        return stream.ReadByte();
    }

    public override byte Lower(byte value)
    {
        return value;
    }

    public override int AllocationSize(byte value)
    {
        return 1;
    }

    public override void Write(byte value, BigEndianStream stream)
    {
        stream.WriteByte(value);
    }
}

class FfiConverterUInt32 : FfiConverter<uint, uint>
{
    public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

    public override uint Lift(uint value)
    {
        return value;
    }

    public override uint Read(BigEndianStream stream)
    {
        return stream.ReadUInt();
    }

    public override uint Lower(uint value)
    {
        return value;
    }

    public override int AllocationSize(uint value)
    {
        return 4;
    }

    public override void Write(uint value, BigEndianStream stream)
    {
        stream.WriteUInt(value);
    }
}

class FfiConverterUInt64 : FfiConverter<ulong, ulong>
{
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value)
    {
        return value;
    }

    public override ulong Read(BigEndianStream stream)
    {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value)
    {
        return value;
    }

    public override int AllocationSize(ulong value)
    {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream)
    {
        stream.WriteULong(value);
    }
}

class FfiConverterFloat : FfiConverter<float, float>
{
    public static FfiConverterFloat INSTANCE = new FfiConverterFloat();

    public override float Lift(float value)
    {
        return value;
    }

    public override float Read(BigEndianStream stream)
    {
        return stream.ReadFloat();
    }

    public override float Lower(float value)
    {
        return value;
    }

    public override int AllocationSize(float value)
    {
        return 4;
    }

    public override void Write(float value, BigEndianStream stream)
    {
        stream.WriteFloat(value);
    }
}

class FfiConverterBoolean : FfiConverter<bool, sbyte>
{
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value)
    {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream)
    {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value)
    {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value)
    {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream)
    {
        stream.WriteSByte(Lower(value));
    }
}

class FfiConverterString : FfiConverter<string, RustBuffer>
{
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value)
    {
        try
        {
            var bytes = value.AsStream().ReadBytes(value.len);
            return System.Text.Encoding.UTF8.GetString(bytes);
        }
        finally
        {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value)
    {
        const int sizeForLength = 4;
        var sizeForString = value.Length * 3;
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}

class FfiConverterByteArray : FfiConverterRustBuffer<byte[]>
{
    public static FfiConverterByteArray INSTANCE = new FfiConverterByteArray();

    public override byte[] Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        return stream.ReadBytes(length);
    }

    public override int AllocationSize(byte[] value)
    {
        return 4 + value.Length;
    }

    public override void Write(byte[] value, BigEndianStream stream)
    {
        stream.WriteInt(value.Length);
        stream.WriteBytes(value);
    }
}

internal abstract class FFIObject : IDisposable
{
    protected IntPtr pointer;

    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    protected FFIObject(IntPtr pointer)
    {
        this.pointer = pointer;
    }

    protected abstract void FreeRustArcPtr();

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    ~FFIObject()
    {
        Destroy();
    }

    private void IncrementCallCounter()
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L)
                throw new System.ObjectDisposedException(
                    String.Format(
                        "'{0}' object has already been destroyed",
                        this.GetType().Name
                    )
                );
            if (count == long.MaxValue)
                throw new System.OverflowException(
                    String.Format(
                        "'{0}' call counter would overflow",
                        this.GetType().Name
                    )
                );
        } while (
            Interlocked.CompareExchange(ref _callCounter, count + 1, count)
            != count
        );
    }

    private void DecrementCallCounter()
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0)
        {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try
        {
            action(this.pointer);
        }
        finally
        {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {
        IncrementCallCounter();
        try
        {
            return func(this.pointer);
        }
        finally
        {
            DecrementCallCounter();
        }
    }
}

internal interface IAnyError { }

internal class AnyError : FFIObject, IAnyError
{
    public AnyError(IntPtr pointer)
        : base(pointer) { }

    protected override void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                _UniFFILib.uniffi_rat_object_detection_fn_free_anyerror(
                    this.pointer,
                    ref status
                );
            }
        );
    }
}

class FfiConverterTypeAnyError : FfiConverter<AnyError, IntPtr>
{
    public static FfiConverterTypeAnyError INSTANCE =
        new FfiConverterTypeAnyError();

    public override IntPtr Lower(AnyError value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override AnyError Lift(IntPtr value)
    {
        return new AnyError(value);
    }

    public override AnyError Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(AnyError value)
    {
        return 8;
    }

    public override void Write(AnyError value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal interface IRatDetector
{
    /// <exception cref="GenericException"></exception>
    RunResult Run(RunArgs? @args);
}

internal class RatDetector : FFIObject, IRatDetector
{
    public RatDetector(IntPtr pointer)
        : base(pointer) { }

    protected override void FreeRustArcPtr()
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                _UniFFILib.uniffi_rat_object_detection_fn_free_ratdetector(
                    this.pointer,
                    ref status
                );
            }
        );
    }

    /// <exception cref="GenericException"></exception>
    public RunResult Run(RunArgs? @args)
    {
        return CallWithPointer(thisPtr =>
            FfiConverterTypeRunResult.INSTANCE.Lift(
                _UniffiHelpers.RustCallWithError(
                    FfiConverterTypeGenericException.INSTANCE,
                    (ref RustCallStatus _status) =>
                        _UniFFILib.uniffi_rat_object_detection_fn_method_ratdetector_run(
                            thisPtr,
                            FfiConverterOptionalTypeRunArgs.INSTANCE.Lower(
                                @args
                            ),
                            ref _status
                        )
                )
            )
        );
    }
}

class FfiConverterTypeRatDetector : FfiConverter<RatDetector, IntPtr>
{
    public static FfiConverterTypeRatDetector INSTANCE =
        new FfiConverterTypeRatDetector();

    public override IntPtr Lower(RatDetector value)
    {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override RatDetector Lift(IntPtr value)
    {
        return new RatDetector(value);
    }

    public override RatDetector Read(BigEndianStream stream)
    {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RatDetector value)
    {
        return 8;
    }

    public override void Write(RatDetector value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).ToInt64());
    }
}

internal record BoundingBox(ulong @x, ulong @y, ulong @width, ulong @height) { }

class FfiConverterTypeBoundingBox : FfiConverterRustBuffer<BoundingBox>
{
    public static FfiConverterTypeBoundingBox INSTANCE =
        new FfiConverterTypeBoundingBox();

    public override BoundingBox Read(BigEndianStream stream)
    {
        return new BoundingBox(
            @x: FfiConverterUInt64.INSTANCE.Read(stream),
            @y: FfiConverterUInt64.INSTANCE.Read(stream),
            @width: FfiConverterUInt64.INSTANCE.Read(stream),
            @height: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(BoundingBox value)
    {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@x)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@y)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@width)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@height);
    }

    public override void Write(BoundingBox value, BigEndianStream stream)
    {
        FfiConverterUInt64.INSTANCE.Write(value.@x, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@y, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@width, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@height, stream);
    }
}

internal record CameraResolution(uint @width, uint @height, uint @fps) { }

class FfiConverterTypeCameraResolution
    : FfiConverterRustBuffer<CameraResolution>
{
    public static FfiConverterTypeCameraResolution INSTANCE =
        new FfiConverterTypeCameraResolution();

    public override CameraResolution Read(BigEndianStream stream)
    {
        return new CameraResolution(
            @width: FfiConverterUInt32.INSTANCE.Read(stream),
            @height: FfiConverterUInt32.INSTANCE.Read(stream),
            @fps: FfiConverterUInt32.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CameraResolution value)
    {
        return 0
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@width)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@height)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@fps);
    }

    public override void Write(CameraResolution value, BigEndianStream stream)
    {
        FfiConverterUInt32.INSTANCE.Write(value.@width, stream);
        FfiConverterUInt32.INSTANCE.Write(value.@height, stream);
        FfiConverterUInt32.INSTANCE.Write(value.@fps, stream);
    }
}

internal record Detection(
    String @label,
    float @probability,
    BoundingBox @boundingBox
) { }

class FfiConverterTypeDetection : FfiConverterRustBuffer<Detection>
{
    public static FfiConverterTypeDetection INSTANCE =
        new FfiConverterTypeDetection();

    public override Detection Read(BigEndianStream stream)
    {
        return new Detection(
            @label: FfiConverterString.INSTANCE.Read(stream),
            @probability: FfiConverterFloat.INSTANCE.Read(stream),
            @boundingBox: FfiConverterTypeBoundingBox.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Detection value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@label)
            + FfiConverterFloat.INSTANCE.AllocationSize(value.@probability)
            + FfiConverterTypeBoundingBox.INSTANCE.AllocationSize(
                value.@boundingBox
            );
    }

    public override void Write(Detection value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@label, stream);
        FfiConverterFloat.INSTANCE.Write(value.@probability, stream);
        FfiConverterTypeBoundingBox.INSTANCE.Write(value.@boundingBox, stream);
    }
}

internal record RunArgs(
    float? @minConfidence,
    bool? @showLabels,
    bool? @showConfidence,
    CameraResolution? @cameraResolution,
    bool? @detectRats
) { }

class FfiConverterTypeRunArgs : FfiConverterRustBuffer<RunArgs>
{
    public static FfiConverterTypeRunArgs INSTANCE =
        new FfiConverterTypeRunArgs();

    public override RunArgs Read(BigEndianStream stream)
    {
        return new RunArgs(
            @minConfidence: FfiConverterOptionalFloat.INSTANCE.Read(stream),
            @showLabels: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @showConfidence: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @cameraResolution: FfiConverterOptionalTypeCameraResolution.INSTANCE.Read(
                stream
            ),
            @detectRats: FfiConverterOptionalBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RunArgs value)
    {
        return 0
            + FfiConverterOptionalFloat.INSTANCE.AllocationSize(
                value.@minConfidence
            )
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(
                value.@showLabels
            )
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(
                value.@showConfidence
            )
            + FfiConverterOptionalTypeCameraResolution.INSTANCE.AllocationSize(
                value.@cameraResolution
            )
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(
                value.@detectRats
            );
    }

    public override void Write(RunArgs value, BigEndianStream stream)
    {
        FfiConverterOptionalFloat.INSTANCE.Write(value.@minConfidence, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@showLabels, stream);
        FfiConverterOptionalBoolean.INSTANCE.Write(
            value.@showConfidence,
            stream
        );
        FfiConverterOptionalTypeCameraResolution.INSTANCE.Write(
            value.@cameraResolution,
            stream
        );
        FfiConverterOptionalBoolean.INSTANCE.Write(value.@detectRats, stream);
    }
}

internal record RunResult(
    List<Detection> @detections,
    byte[] @frame,
    FrameFormat @frameFormat
) { }

class FfiConverterTypeRunResult : FfiConverterRustBuffer<RunResult>
{
    public static FfiConverterTypeRunResult INSTANCE =
        new FfiConverterTypeRunResult();

    public override RunResult Read(BigEndianStream stream)
    {
        return new RunResult(
            @detections: FfiConverterSequenceTypeDetection.INSTANCE.Read(
                stream
            ),
            @frame: FfiConverterByteArray.INSTANCE.Read(stream),
            @frameFormat: FfiConverterTypeFrameFormat.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RunResult value)
    {
        return 0
            + FfiConverterSequenceTypeDetection.INSTANCE.AllocationSize(
                value.@detections
            )
            + FfiConverterByteArray.INSTANCE.AllocationSize(value.@frame)
            + FfiConverterTypeFrameFormat.INSTANCE.AllocationSize(
                value.@frameFormat
            );
    }

    public override void Write(RunResult value, BigEndianStream stream)
    {
        FfiConverterSequenceTypeDetection.INSTANCE.Write(
            value.@detections,
            stream
        );
        FfiConverterByteArray.INSTANCE.Write(value.@frame, stream);
        FfiConverterTypeFrameFormat.INSTANCE.Write(value.@frameFormat, stream);
    }
}

internal record SessionOptions(
    byte? @intraThreads,
    SessionGraphOptimizationLevel? @optimizationLevel
) { }

class FfiConverterTypeSessionOptions : FfiConverterRustBuffer<SessionOptions>
{
    public static FfiConverterTypeSessionOptions INSTANCE =
        new FfiConverterTypeSessionOptions();

    public override SessionOptions Read(BigEndianStream stream)
    {
        return new SessionOptions(
            @intraThreads: FfiConverterOptionalUInt8.INSTANCE.Read(stream),
            @optimizationLevel: FfiConverterOptionalTypeSessionGraphOptimizationLevel.INSTANCE.Read(
                stream
            )
        );
    }

    public override int AllocationSize(SessionOptions value)
    {
        return 0
            + FfiConverterOptionalUInt8.INSTANCE.AllocationSize(
                value.@intraThreads
            )
            + FfiConverterOptionalTypeSessionGraphOptimizationLevel.INSTANCE.AllocationSize(
                value.@optimizationLevel
            );
    }

    public override void Write(SessionOptions value, BigEndianStream stream)
    {
        FfiConverterOptionalUInt8.INSTANCE.Write(value.@intraThreads, stream);
        FfiConverterOptionalTypeSessionGraphOptimizationLevel.INSTANCE.Write(
            value.@optimizationLevel,
            stream
        );
    }
}

internal enum FrameFormat : int
{
    Jpeg,
    Png,
}

class FfiConverterTypeFrameFormat : FfiConverterRustBuffer<FrameFormat>
{
    public static FfiConverterTypeFrameFormat INSTANCE =
        new FfiConverterTypeFrameFormat();

    public override FrameFormat Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(FrameFormat), value))
        {
            return (FrameFormat)value;
        }
        else
        {
            throw new InternalException(
                String.Format(
                    "invalid enum value '{0}' in FfiConverterTypeFrameFormat.Read()",
                    value
                )
            );
        }
    }

    public override int AllocationSize(FrameFormat value)
    {
        return 4;
    }

    public override void Write(FrameFormat value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal class GenericException : UniffiException
{
    // Each variant is a nested class


    public class Generic : GenericException
    {
        // Members
        public String @message;

        // Constructor
        public Generic(String @message)
        {
            this.@message = @message;
        }
    }
}

class FfiConverterTypeGenericException
    : FfiConverterRustBuffer<GenericException>,
        CallStatusErrorHandler<GenericException>
{
    public static FfiConverterTypeGenericException INSTANCE =
        new FfiConverterTypeGenericException();

    public override GenericException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new GenericException.Generic(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeGenericException.Read()",
                        value
                    )
                );
        }
    }

    public override int AllocationSize(GenericException value)
    {
        switch (value)
        {
            case GenericException.Generic variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(
                        variant_value.@message
                    );
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeGenericException.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(GenericException value, BigEndianStream stream)
    {
        switch (value)
        {
            case GenericException.Generic variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(
                    variant_value.@message,
                    stream
                );
                break;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeGenericException.Write()",
                        value
                    )
                );
        }
    }
}

internal enum SessionGraphOptimizationLevel : int
{
    Disable,
    Level1,
    Level2,
    Level3,
}

class FfiConverterTypeSessionGraphOptimizationLevel
    : FfiConverterRustBuffer<SessionGraphOptimizationLevel>
{
    public static FfiConverterTypeSessionGraphOptimizationLevel INSTANCE =
        new FfiConverterTypeSessionGraphOptimizationLevel();

    public override SessionGraphOptimizationLevel Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(SessionGraphOptimizationLevel), value))
        {
            return (SessionGraphOptimizationLevel)value;
        }
        else
        {
            throw new InternalException(
                String.Format(
                    "invalid enum value '{0}' in FfiConverterTypeSessionGraphOptimizationLevel.Read()",
                    value
                )
            );
        }
    }

    public override int AllocationSize(SessionGraphOptimizationLevel value)
    {
        return 4;
    }

    public override void Write(
        SessionGraphOptimizationLevel value,
        BigEndianStream stream
    )
    {
        stream.WriteInt((int)value + 1);
    }
}

class FfiConverterOptionalUInt8 : FfiConverterRustBuffer<byte?>
{
    public static FfiConverterOptionalUInt8 INSTANCE =
        new FfiConverterOptionalUInt8();

    public override byte? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterUInt8.INSTANCE.Read(stream);
    }

    public override int AllocationSize(byte? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterUInt8.INSTANCE.AllocationSize((byte)value);
        }
    }

    public override void Write(byte? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterUInt8.INSTANCE.Write((byte)value, stream);
        }
    }
}

class FfiConverterOptionalFloat : FfiConverterRustBuffer<float?>
{
    public static FfiConverterOptionalFloat INSTANCE =
        new FfiConverterOptionalFloat();

    public override float? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterFloat.INSTANCE.Read(stream);
    }

    public override int AllocationSize(float? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterFloat.INSTANCE.AllocationSize((float)value);
        }
    }

    public override void Write(float? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterFloat.INSTANCE.Write((float)value, stream);
        }
    }
}

class FfiConverterOptionalBoolean : FfiConverterRustBuffer<bool?>
{
    public static FfiConverterOptionalBoolean INSTANCE =
        new FfiConverterOptionalBoolean();

    public override bool? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterBoolean.INSTANCE.Read(stream);
    }

    public override int AllocationSize(bool? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterBoolean.INSTANCE.AllocationSize((bool)value);
        }
    }

    public override void Write(bool? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterBoolean.INSTANCE.Write((bool)value, stream);
        }
    }
}

class FfiConverterOptionalTypeCameraResolution
    : FfiConverterRustBuffer<CameraResolution?>
{
    public static FfiConverterOptionalTypeCameraResolution INSTANCE =
        new FfiConverterOptionalTypeCameraResolution();

    public override CameraResolution? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeCameraResolution.INSTANCE.Read(stream);
    }

    public override int AllocationSize(CameraResolution? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeCameraResolution.INSTANCE.AllocationSize(
                    (CameraResolution)value
                );
        }
    }

    public override void Write(CameraResolution? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeCameraResolution.INSTANCE.Write(
                (CameraResolution)value,
                stream
            );
        }
    }
}

class FfiConverterOptionalTypeRunArgs : FfiConverterRustBuffer<RunArgs?>
{
    public static FfiConverterOptionalTypeRunArgs INSTANCE =
        new FfiConverterOptionalTypeRunArgs();

    public override RunArgs? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeRunArgs.INSTANCE.Read(stream);
    }

    public override int AllocationSize(RunArgs? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeRunArgs.INSTANCE.AllocationSize(
                    (RunArgs)value
                );
        }
    }

    public override void Write(RunArgs? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeRunArgs.INSTANCE.Write((RunArgs)value, stream);
        }
    }
}

class FfiConverterOptionalTypeSessionOptions
    : FfiConverterRustBuffer<SessionOptions?>
{
    public static FfiConverterOptionalTypeSessionOptions INSTANCE =
        new FfiConverterOptionalTypeSessionOptions();

    public override SessionOptions? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeSessionOptions.INSTANCE.Read(stream);
    }

    public override int AllocationSize(SessionOptions? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeSessionOptions.INSTANCE.AllocationSize(
                    (SessionOptions)value
                );
        }
    }

    public override void Write(SessionOptions? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeSessionOptions.INSTANCE.Write(
                (SessionOptions)value,
                stream
            );
        }
    }
}

class FfiConverterOptionalTypeSessionGraphOptimizationLevel
    : FfiConverterRustBuffer<SessionGraphOptimizationLevel?>
{
    public static FfiConverterOptionalTypeSessionGraphOptimizationLevel INSTANCE =
        new FfiConverterOptionalTypeSessionGraphOptimizationLevel();

    public override SessionGraphOptimizationLevel? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeSessionGraphOptimizationLevel.INSTANCE.Read(
            stream
        );
    }

    public override int AllocationSize(SessionGraphOptimizationLevel? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeSessionGraphOptimizationLevel.INSTANCE.AllocationSize(
                    (SessionGraphOptimizationLevel)value
                );
        }
    }

    public override void Write(
        SessionGraphOptimizationLevel? value,
        BigEndianStream stream
    )
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeSessionGraphOptimizationLevel.INSTANCE.Write(
                (SessionGraphOptimizationLevel)value,
                stream
            );
        }
    }
}

class FfiConverterSequenceTypeDetection
    : FfiConverterRustBuffer<List<Detection>>
{
    public static FfiConverterSequenceTypeDetection INSTANCE =
        new FfiConverterSequenceTypeDetection();

    public override List<Detection> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<Detection>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterTypeDetection.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Detection> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item =>
                FfiConverterTypeDetection.INSTANCE.AllocationSize(item)
            )
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Detection> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item =>
            FfiConverterTypeDetection.INSTANCE.Write(item, stream)
        );
    }
}
#pragma warning restore 8625
internal static class RatObjectDetectionMethods
{
    /// <exception cref="GenericException"></exception>
    public static void Initialize()
    {
        _UniffiHelpers.RustCallWithError(
            FfiConverterTypeGenericException.INSTANCE,
            (ref RustCallStatus _status) =>
                _UniFFILib.uniffi_rat_object_detection_fn_func_initialize(
                    ref _status
                )
        );
    }

    /// <exception cref="GenericException"></exception>
    public static RatDetector NewRatDetectorFromDefaultModelAndVideoCaptureFile(
        String @videoCaptureFile,
        SessionOptions? @options
    )
    {
        return FfiConverterTypeRatDetector.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeGenericException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_rat_object_detection_fn_func_new_rat_detector_from_default_model_and_video_capture_file(
                        FfiConverterString.INSTANCE.Lower(@videoCaptureFile),
                        FfiConverterOptionalTypeSessionOptions.INSTANCE.Lower(
                            @options
                        ),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="GenericException"></exception>
    public static RatDetector NewRatDetectorFromDefaultModelAndVideoCaptureIndex(
        uint @videoCaptureIndex,
        SessionOptions? @options
    )
    {
        return FfiConverterTypeRatDetector.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeGenericException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_rat_object_detection_fn_func_new_rat_detector_from_default_model_and_video_capture_index(
                        FfiConverterUInt32.INSTANCE.Lower(@videoCaptureIndex),
                        FfiConverterOptionalTypeSessionOptions.INSTANCE.Lower(
                            @options
                        ),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="GenericException"></exception>
    public static RatDetector NewRatDetectorFromFiles(
        String @modelFile,
        String @videoCaptureFile,
        SessionOptions? @options
    )
    {
        return FfiConverterTypeRatDetector.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeGenericException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_rat_object_detection_fn_func_new_rat_detector_from_files(
                        FfiConverterString.INSTANCE.Lower(@modelFile),
                        FfiConverterString.INSTANCE.Lower(@videoCaptureFile),
                        FfiConverterOptionalTypeSessionOptions.INSTANCE.Lower(
                            @options
                        ),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="GenericException"></exception>
    public static RatDetector NewRatDetectorFromModelBytesAndVideoCaptureFile(
        byte[] @modelBytes,
        String @videoCaptureFile,
        SessionOptions? @options
    )
    {
        return FfiConverterTypeRatDetector.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeGenericException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_rat_object_detection_fn_func_new_rat_detector_from_model_bytes_and_video_capture_file(
                        FfiConverterByteArray.INSTANCE.Lower(@modelBytes),
                        FfiConverterString.INSTANCE.Lower(@videoCaptureFile),
                        FfiConverterOptionalTypeSessionOptions.INSTANCE.Lower(
                            @options
                        ),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="GenericException"></exception>
    public static RatDetector NewRatDetectorFromModelBytesAndVideoCaptureIndex(
        byte[] @modelBytes,
        uint @videoCaptureIndex,
        SessionOptions? @options
    )
    {
        return FfiConverterTypeRatDetector.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeGenericException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_rat_object_detection_fn_func_new_rat_detector_from_model_bytes_and_video_capture_index(
                        FfiConverterByteArray.INSTANCE.Lower(@modelBytes),
                        FfiConverterUInt32.INSTANCE.Lower(@videoCaptureIndex),
                        FfiConverterOptionalTypeSessionOptions.INSTANCE.Lower(
                            @options
                        ),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="GenericException"></exception>
    public static RatDetector NewRatDetectorFromModelFileAndVideoCaptureIndex(
        String @modelFile,
        uint @videoCaptureIndex,
        SessionOptions? @options
    )
    {
        return FfiConverterTypeRatDetector.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeGenericException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_rat_object_detection_fn_func_new_rat_detector_from_model_file_and_video_capture_index(
                        FfiConverterString.INSTANCE.Lower(@modelFile),
                        FfiConverterUInt32.INSTANCE.Lower(@videoCaptureIndex),
                        FfiConverterOptionalTypeSessionOptions.INSTANCE.Lower(
                            @options
                        ),
                        ref _status
                    )
            )
        );
    }
}
